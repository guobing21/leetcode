# week00

### 0.1 写出斐波那契数第n项

提醒：

千万别用递归，因为时间复杂度为O（2^n）,太大

```python
def fun01(n): # 时间O(2^n),空间O(n)
    if n < 2:
        return n
    return fun01(n-1) + fun01(n-2)
    
def myfun02(n):
    l = [0, 1]
    while len(l) < n:
        l.append(l[-1] + l[-2])
        return l[-1]
    
#加缓存 时间O(n)， 空间O(n)
caches = {}
def myfun03(n):
    if n < 2:
        return n
    if n-1 in caches:
        res01 = caches[n-1]
    else:
        res01 = myfun03(n-1)
        caches[n-1] = res01
    if n-2 in caches:
        res02 = caches[n-2]
    else:
        res02 = myfun03(n-2)
        caches[n-2] = res02
    return res01 + res02
    
    from functools import lru_cache

@lru_cache(maxsize=100000)
def myfun04(n):
    if n < 2:
        return n
    return myfun04(n-1) + myfun04(n-2)
    
    
def myfun05(n): #时间O（n）， 空间O(1)
    if n < 2:
        return n
    t0 = 0
    t1 = 1
    for i in range(2, n+1):
        t = t0 + t1
        t0, t1 = t1, t
    return t1
```

### 0.2 时间复杂度



![](E:\my_note\09_geek\my_note\interview_images\微信截图_20200604230609.png)

答案：

除了最后一个是O（logn），其他都是O（n），n是节点数目

### 0.3 空间复杂度

爬楼梯问题

# week01 数组、链表、跳表

## 1.1 数组、链表、跳表的基本实现和特性

### 1 对比数组，链表的时空复杂度

### 2 lru cached，redis用的哪种结构

week07

1对比avl树和红黑树